diff --git a/dummy/Makefile.am b/dummy/Makefile.am
index 305abbd..8d5b94c 100644
--- a/dummy/Makefile.am
+++ b/dummy/Makefile.am
@@ -1,4 +1,4 @@
-DUMMYSRC = dummy.c dummy.h rot_dummy.c rot_dummy.h netrigctl.c netrotctl.c
+DUMMYSRC = dummy.c dummy.h rot_dummy.c rot_dummy.h netrigctl.c netrotctl.c psmtest.h psmtest.c
 
 noinst_LTLIBRARIES = libhamlib-dummy.la
 libhamlib_dummy_la_SOURCES = $(DUMMYSRC)
diff --git a/dummy/dummy.c b/dummy/dummy.c
index fdf46c1..0bcfdf5 100644
--- a/dummy/dummy.c
+++ b/dummy/dummy.c
@@ -1618,6 +1618,7 @@ DECLARE_INITRIG_BACKEND(dummy)
 
 	rig_register(&dummy_caps);
 	rig_register(&netrigctl_caps);
+	rig_register(&psmtest_caps);
 
 	return RIG_OK;
 }
diff --git a/dummy/dummy.h b/dummy/dummy.h
index b80f005..10cbb44 100644
--- a/dummy/dummy.h
+++ b/dummy/dummy.h
@@ -38,5 +38,6 @@
 
 extern const struct rig_caps dummy_caps;
 extern const struct rig_caps netrigctl_caps;
+extern const struct rig_caps psmtest_caps;
 
 #endif /* _DUMMY_H */
diff --git a/dummy/psmtest.c b/dummy/psmtest.c
new file mode 100644
index 0000000..96716a0
--- /dev/null
+++ b/dummy/psmtest.c
@@ -0,0 +1,556 @@
+/*
+ *  Ofcom PSM test backend
+ *  Copyright (c) 2016 by Tom Winch
+ *
+ *
+ *   This library is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU Lesser General Public
+ *   License as published by the Free Software Foundation; either
+ *   version 2.1 of the License, or (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public
+ *   License along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>  /* String function definitions */
+#include <unistd.h>  /* UNIX standard function definitions */
+#include <math.h>
+#include <time.h>
+
+#include "hamlib/rig.h"
+#include "serial.h"
+#include "parallel.h"
+#include "misc.h"
+#include "tones.h"
+#include "idx_builtin.h"
+#include "register.h"
+
+#include "psmtest.h"
+
+#define NB_CHAN 22		/* see caps->chan_list */
+
+struct psmtest_priv_data {
+		/* current vfo already in rig_state ? */
+		vfo_t curr_vfo;
+		vfo_t last_vfo;	/* VFO A or VFO B, when in MEM mode */
+
+		ptt_t ptt;
+		powerstat_t powerstat;
+		int bank;
+		value_t parms[RIG_SETTING_MAX];
+
+		channel_t *curr;	/* points to vfo_a, vfo_b or mem[] */
+
+		channel_t vfo_a;
+		channel_t vfo_b;
+		channel_t mem[NB_CHAN];
+
+		struct ext_list *ext_parms;
+
+        char *magic_conf;
+};
+
+/* levels pertain to each VFO */
+static const struct confparams psmtest_ext_levels[] = {
+	{ TOK_EL_MAGICLEVEL, "MGL", "Magic level", "Magic level, as an example",
+		NULL, RIG_CONF_NUMERIC, { .n = { 0, 1, .001 } }
+	},
+	{ TOK_EL_MAGICFUNC, "MGF", "Magic func", "Magic function, as an example",
+		NULL, RIG_CONF_CHECKBUTTON
+       	},
+	{ TOK_EL_MAGICOP, "MGO", "Magic Op", "Magic Op, as an example",
+		NULL, RIG_CONF_BUTTON
+       	},
+	{ RIG_CONF_END, NULL, }
+};
+
+/* parms pertain to the whole rig */
+static const struct confparams psmtest_ext_parms[] = {
+	{ TOK_EP_MAGICPARM, "MGP", "Magic parm", "Magic parameter, as an example",
+		NULL, RIG_CONF_NUMERIC, { .n = { 0, 1, .001 } }
+	},
+	{ RIG_CONF_END, NULL, }
+};
+
+/* cfgparams are configuration item generally used by the backend's open() method */
+static const struct confparams psmtest_cfg_params[] = {
+	{ TOK_CFG_MAGICCONF, "mcfg", "Magic conf", "Magic parameter, as an example",
+		"DX", RIG_CONF_STRING, { }
+	},
+	{ RIG_CONF_END, NULL, }
+};
+
+/********************************************************************/
+
+static void init_chan(RIG *rig, vfo_t vfo, channel_t *chan)
+{
+  chan->channel_num = 0;
+  chan->vfo = vfo;
+  strcpy(chan->channel_desc, rig_strvfo(vfo));
+
+  chan->freq = MHz(145);
+  chan->mode = RIG_MODE_FM;
+  chan->width = rig_passband_normal(rig, RIG_MODE_FM);
+  chan->tx_freq = chan->freq;
+  chan->tx_mode = chan->mode;
+  chan->tx_width = chan->width;
+  chan->split = RIG_SPLIT_OFF;
+
+  chan->rptr_shift = RIG_RPT_SHIFT_NONE;
+  chan->rptr_offs = 0;
+  chan->ctcss_tone = 0;
+  chan->dcs_code = 0;
+  chan->ctcss_sql = 0;
+  chan->dcs_sql = 0;
+  chan->rit = 0;
+  chan->xit = 0;
+  chan->tuning_step = 0;
+  chan->ant = 0;
+
+  chan->funcs = (setting_t)0;
+  memset(chan->levels, 0, RIG_SETTING_MAX*sizeof(value_t));
+}
+
+static void copy_chan(channel_t *dest, const channel_t *src)
+{
+    struct ext_list *saved_ext_levels;
+    int i;
+
+    /* TODO: ext_levels[] of different sizes */
+
+    for (i=0; !RIG_IS_EXT_END(src->ext_levels[i]) &&
+            !RIG_IS_EXT_END(dest->ext_levels[i]); i++) {
+        dest->ext_levels[i] = src->ext_levels[i];
+    }
+
+    saved_ext_levels = dest->ext_levels;
+    memcpy(dest, src, sizeof(channel_t));
+    dest->ext_levels = saved_ext_levels;
+}
+
+static struct ext_list * alloc_init_ext(const struct confparams *cfp)
+{
+  struct ext_list *elp;
+  int i, nb_ext;
+
+  for (nb_ext=0; !RIG_IS_EXT_END(cfp[nb_ext]); nb_ext++)
+	  ;
+
+  elp = calloc((nb_ext+1), sizeof(struct ext_list));
+  if (!elp)
+	return NULL;
+
+  for (i=0; !RIG_IS_EXT_END(cfp[i]); i++)
+  {
+	  elp[i].token = cfp[i].token;
+	  /* value reset already by calloc */
+  }
+  /* last token in array is set to 0 by calloc */
+
+  return elp;
+}
+
+static struct ext_list * find_ext(struct ext_list *elp, token_t token)
+{
+  int i;
+
+  for (i=0; elp[i].token != 0; i++)
+  {
+    if (elp[i].token == token)
+	    return &elp[i];
+  }
+
+  return NULL;
+}
+
+static int psmtest_init(RIG *rig)
+{
+  struct psmtest_priv_data *priv;
+  int i;
+
+  priv = (struct psmtest_priv_data*)malloc(sizeof(struct psmtest_priv_data));
+  if (!priv)
+		  return -RIG_ENOMEM;
+  rig->state.priv = (void*)priv;
+
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called\n", __FUNCTION__);
+  rig->state.rigport.type.rig = RIG_PORT_NONE;
+
+  priv->ptt = RIG_PTT_OFF;
+  priv->powerstat = RIG_POWER_ON;
+  priv->bank = 0;
+  memset(priv->parms, 0, RIG_SETTING_MAX*sizeof(value_t));
+
+  memset(priv->mem, 0, sizeof(priv->mem));
+  for (i=0; i<NB_CHAN; i++) {
+	priv->mem[i].channel_num = i;
+	priv->mem[i].vfo = RIG_VFO_MEM;
+
+	priv->mem[i].ext_levels = alloc_init_ext(psmtest_ext_levels);
+	if (!priv->mem[i].ext_levels)
+		return -RIG_ENOMEM;
+  }
+
+  priv->vfo_a.ext_levels = alloc_init_ext(psmtest_ext_levels);
+  if (!priv->vfo_a.ext_levels)
+    return -RIG_ENOMEM;
+  priv->vfo_b.ext_levels = alloc_init_ext(psmtest_ext_levels);
+  if (!priv->vfo_b.ext_levels)
+    return -RIG_ENOMEM;
+
+  priv->ext_parms = alloc_init_ext(psmtest_ext_parms);
+  if (!priv->ext_parms)
+    return -RIG_ENOMEM;
+
+  init_chan(rig, RIG_VFO_A, &priv->vfo_a);
+  init_chan(rig, RIG_VFO_B, &priv->vfo_b);
+  priv->curr = &priv->vfo_a;
+  priv->curr_vfo = priv->last_vfo = RIG_VFO_A;
+
+  priv->magic_conf = strdup("DX");
+
+  return RIG_OK;
+}
+
+static int psmtest_cleanup(RIG *rig)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+  int i;
+
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called\n", __FUNCTION__);
+
+  for (i=0; i<NB_CHAN; i++) {
+	free(priv->mem[i].ext_levels);
+  }
+  free(priv->vfo_a.ext_levels);
+  free(priv->vfo_b.ext_levels);
+  free(priv->ext_parms);
+  free(priv->magic_conf);
+
+  if (rig->state.priv)
+  	free(rig->state.priv);
+
+  rig->state.priv = NULL;
+
+  return RIG_OK;
+}
+
+static int psmtest_open(RIG *rig)
+{
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called\n", __FUNCTION__);
+
+  return RIG_OK;
+}
+
+static int psmtest_close(RIG *rig)
+{
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called\n", __FUNCTION__);
+
+  return RIG_OK;
+}
+
+static int psmtest_set_freq(RIG *rig, vfo_t vfo, freq_t freq)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+  channel_t *curr = priv->curr;
+  char fstr[20];
+
+  sprintf_freq(fstr, freq);
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called: %s %s\n", __FUNCTION__,
+ 			rig_strvfo(vfo), fstr);
+  curr->freq = freq;
+
+  return RIG_OK;
+}
+
+
+static int psmtest_get_freq(RIG *rig, vfo_t vfo, freq_t *freq)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+  channel_t *curr = priv->curr;
+
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called: %s\n", __FUNCTION__, rig_strvfo(vfo));
+
+  *freq = curr->freq;
+
+  return RIG_OK;
+}
+
+
+static int psmtest_set_mode(RIG *rig, vfo_t vfo, rmode_t mode, pbwidth_t width)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+  channel_t *curr = priv->curr;
+  char buf[16];
+
+  sprintf_freq(buf, width);
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called: %s %s %s\n", __FUNCTION__,
+  		rig_strvfo(vfo), rig_strrmode(mode), buf);
+
+  curr->mode = mode;
+
+  if (RIG_PASSBAND_NOCHANGE == width) return RIG_OK;
+
+  if (width == RIG_PASSBAND_NORMAL)
+    curr->width = rig_passband_normal(rig, mode);
+  else
+    curr->width = width;
+
+  return RIG_OK;
+}
+
+
+static int psmtest_get_mode(RIG *rig, vfo_t vfo, rmode_t *mode, pbwidth_t *width)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+  channel_t *curr = priv->curr;
+
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called: %s\n", __FUNCTION__, rig_strvfo(vfo));
+
+  *mode = curr->mode;
+  *width = curr->width;
+
+  return RIG_OK;
+}
+
+
+static int psmtest_set_level(RIG *rig, vfo_t vfo, setting_t level, value_t val)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+  channel_t *curr = priv->curr;
+  int idx;
+  char lstr[32];
+
+  idx = rig_setting2idx(level);
+  if (idx >= RIG_SETTING_MAX)
+      return -RIG_EINVAL;
+
+  curr->levels[idx] = val;
+
+  if (RIG_LEVEL_IS_FLOAT(level))
+		  sprintf(lstr, "%f", val.f);
+  else
+		  sprintf(lstr, "%d", val.i);
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called: %s %s\n",__FUNCTION__,
+				  rig_strlevel(level), lstr);
+
+  return RIG_OK;
+}
+
+/* compute the value of the Gaussian height 'amp', position 'f0', width 'fw' at x='freq' */
+static signed int _psmtest_gaussian(freq_t freq, freq_t f0, freq_t fw, signed int amp) {
+  freq_t df2 = pow((freq - f0), 2);
+  freq_t f2w2 = 2 * fw * fw;
+  return amp * exp(-df2 / f2w2);
+}
+
+
+static int psmtest_get_level(RIG *rig, vfo_t vfo, setting_t level, value_t *val)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+  channel_t *curr = priv->curr;
+  int idx;
+
+  idx = rig_setting2idx(level);
+
+  if (idx >= RIG_SETTING_MAX)
+      return -RIG_EINVAL;
+
+  if (level == RIG_LEVEL_STRENGTH || level == RIG_LEVEL_RAWSTR) {
+    usleep(20000);
+
+  	int qrm = -50;
+    qrm += _psmtest_gaussian(curr->freq, MHz(91.4), MHz(0.1), 80);
+    qrm += _psmtest_gaussian(curr->freq, MHz(96.1), MHz(0.1), 90);
+    qrm += _psmtest_gaussian(curr->freq, MHz(100.0), MHz(0.1), 76);
+    qrm += _psmtest_gaussian(curr->freq, MHz(102.3), MHz(0.1), 68);
+
+    /* make S-Meter jiggle */
+  	curr->levels[idx].i = qrm + rand()%4
+      - curr->levels[LVL_ATT].i
+      + curr->levels[LVL_PREAMP].i;
+  }
+
+  *val = curr->levels[idx];
+  rig_debug(RIG_DEBUG_VERBOSE,"%s called: %s\n",__FUNCTION__,
+				  rig_strlevel(level));
+
+  return RIG_OK;
+}
+
+
+static int psmtest_set_powerstat(RIG *rig, powerstat_t status)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+
+  rig_debug(RIG_DEBUG_VERBOSE, "%s called\n", __FUNCTION__);
+  priv->powerstat = status;
+
+  return RIG_OK;
+}
+
+
+static int psmtest_get_powerstat(RIG *rig, powerstat_t *status)
+{
+  struct psmtest_priv_data *priv = (struct psmtest_priv_data *)rig->state.priv;
+
+  *status = priv->powerstat;
+  rig_debug(RIG_DEBUG_VERBOSE, "%s called\n", __FUNCTION__);
+
+  return RIG_OK;
+}
+
+static void chan_vfo(channel_t *chan, vfo_t vfo)
+{
+	chan->vfo = vfo;
+	strcpy(chan->channel_desc, rig_strvfo(vfo));
+}
+
+
+static const char *psmtest_get_info(RIG *rig)
+{
+  rig_debug(RIG_DEBUG_VERBOSE, "%s called\n", __FUNCTION__);
+
+  return "Nothing much (psmtest)";
+}
+
+
+/*
+ * Dummy rig capabilities.
+ */
+
+/*
+ * The following macros set bitmasks for the various funcs, levels, parms,
+ * etc.  This psmtest backend claims support for almost all of them.
+ */
+#define PSMTEST_FUNC  ((setting_t)-1UL) /* All possible functions */
+#define PSMTEST_LEVEL (((setting_t)-1UL)&~(1UL<<27)) /* All levels except SQLSTAT */
+#define PSMTEST_PARM  ((setting_t)-1UL) /* All possible parms */
+
+#define PSMTEST_VFO_OP  0x7ffffffUL /* All possible VFO OPs */
+#define PSMTEST_SCAN    0x7ffffffUL /* All possible scan OPs */
+
+#define PSMTEST_VFOS (RIG_VFO_A|RIG_VFO_B|RIG_VFO_MEM)
+
+#define PSMTEST_MODES (RIG_MODE_AM | RIG_MODE_CW | RIG_MODE_RTTY | \
+                     RIG_MODE_SSB | RIG_MODE_FM | RIG_MODE_WFM | \
+                     RIG_MODE_CWR | RIG_MODE_RTTYR)
+
+#define PSMTEST_MEM_CAP {    \
+	.bank_num = 1,	\
+	.vfo = 1,	\
+	.ant = 1,	\
+	.freq = 1,	\
+	.mode = 1,	\
+	.width = 1,	\
+	.tx_freq = 1,	\
+	.tx_mode = 1,	\
+	.tx_width = 1,	\
+	.split = 1,	\
+	.rptr_shift = 1,	\
+	.rptr_offs = 1,	\
+	.tuning_step = 1,	\
+	.rit = 1,	\
+	.xit = 1,	\
+	.funcs = PSMTEST_FUNC,	\
+	.levels = RIG_LEVEL_SET(PSMTEST_LEVEL),	\
+	.ctcss_tone = 1,	\
+	.ctcss_sql = 1,	\
+	.dcs_code = 1,	\
+	.dcs_sql = 1,	\
+	.scan_group = 1,	\
+	.flags = 1,	\
+	.channel_desc = 1,	\
+	.ext_levels = 1,	\
+	}
+
+const struct rig_caps psmtest_caps = {
+  .rig_model =      RIG_MODEL_PSMTEST,
+  .model_name =     "PSM Test",
+  .mfg_name =       "Ofcom",
+  .version =        "0.1",
+  .copyright =      "LGPL",
+  .status =         RIG_STATUS_BETA,
+  .rig_type =       RIG_TYPE_OTHER,
+  .targetable_vfo = 	 0,
+  .ptt_type =       RIG_PTT_RIG,
+  .dcd_type =       RIG_DCD_RIG,
+  .port_type =      RIG_PORT_NONE,
+  .has_get_func =   PSMTEST_FUNC,
+  .has_set_func =   PSMTEST_FUNC,
+  .has_get_level =  PSMTEST_LEVEL,
+  .has_set_level =  RIG_LEVEL_SET(PSMTEST_LEVEL),
+  .has_get_parm = 	 PSMTEST_PARM,
+  .has_set_parm = 	 RIG_PARM_SET(PSMTEST_PARM),
+  .level_gran =		 { [LVL_CWPITCH] = { .step = { .i = 10 } } },
+  .ctcss_list = 	 common_ctcss_list,
+  .dcs_list =   	 full_dcs_list,
+  .chan_list = 	 {
+			{   0,  18, RIG_MTYPE_MEM, PSMTEST_MEM_CAP },
+			{  19,  19, RIG_MTYPE_CALL },
+			{  20,  NB_CHAN-1, RIG_MTYPE_EDGE },
+			RIG_CHAN_END,
+		 },
+  .scan_ops = 	 PSMTEST_SCAN,
+  .vfo_ops = 	 PSMTEST_VFO_OP,
+  .transceive =     RIG_TRN_OFF,
+  .attenuator =     { 10, 20, 30, RIG_DBLST_END, },
+  .preamp = 		 { 10, RIG_DBLST_END, },
+  .rx_range_list1 =  { {.start=kHz(150),.end=MHz(1500),.modes=PSMTEST_MODES,
+                        .low_power=-1,.high_power=-1,PSMTEST_VFOS, RIG_ANT_1|RIG_ANT_2},
+                        RIG_FRNG_END, },
+  .tx_range_list1 =  { RIG_FRNG_END, },
+  .rx_range_list2 =  { {.start=kHz(150),.end=MHz(1500),.modes=PSMTEST_MODES,
+                        .low_power=-1,.high_power=-1,PSMTEST_VFOS, RIG_ANT_1|RIG_ANT_2},
+                        RIG_FRNG_END, },
+  .tx_range_list2 =  { RIG_FRNG_END, },
+  .tuning_steps =  { {PSMTEST_MODES,1}, {PSMTEST_MODES,RIG_TS_ANY}, RIG_TS_END, },
+  .filters =  {
+	{RIG_MODE_SSB|RIG_MODE_CW|RIG_MODE_RTTY, kHz(2.4)},
+	{RIG_MODE_CW, Hz(500)},
+	{RIG_MODE_AM, kHz(8)},
+	{RIG_MODE_AM, kHz(2.4)},
+	{RIG_MODE_FM, kHz(15)},
+	{RIG_MODE_FM, kHz(8)},
+	{RIG_MODE_WFM, kHz(230)},
+	RIG_FLT_END,
+  },
+  .max_rit = 9990,
+  .max_xit = 9990,
+  .max_ifshift = 10000,
+  .priv =  NULL,	/* priv */
+
+  .extlevels =    psmtest_ext_levels,
+  .extparms =     psmtest_ext_parms,
+  .cfgparams =    psmtest_cfg_params,
+
+  .rig_init =     psmtest_init,
+  .rig_cleanup =  psmtest_cleanup,
+  .rig_open =     psmtest_open,
+  .rig_close =    psmtest_close,
+
+  .set_freq =     psmtest_set_freq,
+  .get_freq =     psmtest_get_freq,
+  .set_mode =     psmtest_set_mode,
+  .get_mode =     psmtest_get_mode,
+
+  .set_powerstat =  psmtest_set_powerstat,
+  .get_powerstat =  psmtest_get_powerstat,
+  .set_level =     psmtest_set_level,
+  .get_level =     psmtest_get_level,
+
+  .get_info =      psmtest_get_info,
+};
diff --git a/dummy/psmtest.h b/dummy/psmtest.h
new file mode 100644
index 0000000..81eb527
--- /dev/null
+++ b/dummy/psmtest.h
@@ -0,0 +1,38 @@
+/*
+ *  Hamlib Dummy backend - main header
+ *  Copyright (c) 2001-2009 by Stephane Fillod
+ *
+ *
+ *   This library is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU Lesser General Public
+ *   License as published by the Free Software Foundation; either
+ *   version 2.1 of the License, or (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public
+ *   License along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _PSMTEST_H
+#define _PSMTEST_H 1
+
+#include "hamlib/rig.h"
+#include "token.h"
+
+/* backend conf */
+#define TOK_CFG_MAGICCONF  TOKEN_BACKEND(1)
+
+
+/* ext_level's and ext_parm's tokens */
+#define TOK_EL_MAGICLEVEL  TOKEN_BACKEND(1)
+#define TOK_EL_MAGICFUNC   TOKEN_BACKEND(2)
+#define TOK_EL_MAGICOP     TOKEN_BACKEND(3)
+#define TOK_EP_MAGICPARM   TOKEN_BACKEND(4)
+
+#endif /* _PSMTEST_H */
diff --git a/include/hamlib/riglist.h b/include/hamlib/riglist.h
index 6edf78e..3bcf4d5 100644
--- a/include/hamlib/riglist.h
+++ b/include/hamlib/riglist.h
@@ -56,6 +56,7 @@
 #define RIG_MODEL_DUMMY RIG_MAKE_MODEL(RIG_DUMMY, 1)
 #define RIG_MODEL_NETRIGCTL RIG_MAKE_MODEL(RIG_DUMMY, 2)
 #define RIG_MODEL_ARMSTRONG RIG_MAKE_MODEL(RIG_DUMMY, 3)
+#define RIG_MODEL_PSMTEST RIG_MAKE_MODEL(RIG_DUMMY, 4)
 
 	/*
 	 * Yaesu
